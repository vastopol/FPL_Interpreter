to read / load a file
//--------------------------------------

have file structrued in procedural order.
each statement should end with a terminating symbol. probably ';'

1
read in each line, construct a string and put to list.

std::list<std::string> argv;
while(!EOF)
{
    std::string temp;
    // fill with chars up to ';' and then discard semicolon
    argv.push_back(temp);
}

2
have a list of strings representing commands to execute in sequential order, "argv"

then,

std::stack<std::string> stk; // stack commands in history order
while(!argv.empty())
{
    
    // do current task
    
    //same sequence in main
    
    if(str.at(0) == '#')
    {
        pattern
        PARSE
        EXEC
    }
    else
    {
        com()
    }
    
}
----------------------------------------------------------------

OPERATIONS:
//==========================================================================

load file.fps == loads the contents of file.fps into the system buffer

run == execute content of the system buffer. if buffer is empty will not work.
    system buffer is a queue of commands to be executed in order. each command is executed, 
    and removed from the queue. continues until queue is empty.

//==========================================================================

FP_REPL scripting

FP_REPL supports scripting of system commands and evaluations.
repl scripts need to end with file extention ".fps"

scripts are lists of statements to be performed in sequential order
each statement must end with an ';'
proper structure: define variables, then have operations

def ELEMENTS/SEQUENCES
mac MACROS
system commands
evaluation '#'
