// maybe not needed anymore... to FP syntax


bool isEqn(std::queue<std::string> Q);

bool isEqn(std::queue<std::string> Que) // segfault?? maybe
{    
    if(Que.empty()) return false; // err chk?
     
    while(!Que.empty())
    {
        if(Que.front() != "=" && Que.front() != "!=" && Que.front() != "<" && Que.front() != "<=" && Que.front() != ">" && Que.front() != ">=") 
        {
            Que.pop();
        }
        else
        {
            break;
        }
    }
    
    // should still have pieces left if there is an eval sign
    return !Que.empty();
}
//-------------------------------------------------------------------------------------------


// right after prelim checks...


//LOCAL VARS
   std::queue<std::string> Que;     // begining string
   std::queue<std::string> QueL;    // if eqn holds left side
   std::queue<std::string> QueR;    // if eqn holds right side
   std::string temp;                // if eqn holds comparator
   
   // take out space character spearators
   unsigned i = 0;
   unsigned j = 0;
   for(; i < str.size(); i++)
   {
      if(str.at(i) == ' ' || i == str.size()-1)
      {
         for(; j <= i ; j++)
         {
            temp += str.at(j);
         }
         
         if(j != str.size())
         {
            temp = temp.substr(0,temp.size()-1); // get rid of the space after the string 
         }
         Que.push(temp);
         temp.clear();
      }
   }
   
   // now at this point Q contains pieces separate but in order, no spaces
   // if an equation then
   // have to separate into sub parts to be evaluated separately and compared
   // QueL = left half before eval sign
   // QueR = right half after eval sign
   // set temp = eval sign and use that aside
   // else evaluate expression


    // err check
    if(Que.empty())
    {
      cout << "Error:: empty Queue in eval function" << endl; 
      return false;
    }

    if(isEqn(Que))   
    {
        cout << "Equation not done" << endl; //*****
        
        while(Que.front() != "=" && Que.front() != "!=" && Que.front() != "<" && Que.front() != "<=" && Que.front() != ">" && Que.front() != ">=")
        {
            QueL.push(Que.front()); //fill Queue for left side
            Que.pop();
        }
        
        temp = Que.front(); Que.pop();  // capture the evaluator
        QueR = Que;                     // fill Queue for right side with leftovers
        
        
        // NOW, have branch for temp to choose how after evaluation what corresponding truth value is for A vs B
        // all cases for each possibility plus default catch
        // recursive eval each half and compare
        // return truth value
        
        
        /*
            bool z = false;
            x = recurEval(QueL) ??
            y = recurEval(QueR) ??
        
            if(temp == "=")         // =
            {
            }
            else if(temp == "!=")   // !=
            {
            }
            else if(temp == "<")    // <
            {
            }
            else if(temp == "<=")   // <=
            {
            }
            else if(temp == ">")    // >
            {
            }
            else if(temp == ">=")   // >=
            {
            }
            else        //default catch
            {
                cout << "ERROR:: unknown evaluator" << endl;
                return false;
            }
        
        */
        
        
        
        //   cout << "After" << endl;
        
        //   while(!QueL.empty())
        //   {
        //       cout << QueL.front() << ',';// << ',' << endl;
        //       QueL.pop();
        //   }
          
        //   cout << endl << temp << endl;
          
        //   while(!QueR.empty())
        //   {
        //       cout << QueR.front() << ',';// << ',' << endl;
        //       QueR.pop();
        //   }
          
    }
    else    
    {
        // run through recursive evauator output result && true
        cout << "Expression" << endl;
        
        //   while(!Que.empty())
        //   {
        //       cout << Que.front() << ',';
        //       Que.pop();
        //   }
      
      
      cout << "not done expression evaluator" << endl;
        
    }
    
    
 //   ============================================================
    
    /*

        char* copy = 0;        // copy to give strtok for parse
        char* arr = 0;         // temp array
        vector<string> matrix; // argument vector - contains substrings
        copy = (char*)(str.c_str()); // copy string to char array for strtok
        
        // parse on "()"

        arr = strtok(copy, "()");
        matrix.push_back(string(arr));
        for(unsigned i = 1; arr != 0; i++)
        {
            arr = strtok(NULL, "()");
            if(arr)
            {
                matrix.push_back(string(arr));
            }
        }            
        
        // parse check
        for(unsigned i = 0; i < matrix.size(); i++)
        {
            cout << matrix.at(i) << ',';
        }
        cout << endl;
        
        // now must parse individual matrix substrings individually
        
*/