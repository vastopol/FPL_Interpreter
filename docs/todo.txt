TODO

DONE:
    * func.h/cpp -> add more functions for the vm fn_pointers from the math.h library
        * pow, log, gcd
    * separate out operators from the action class
    * ccf{}
    * red{}
    * constants ~0 and ~1
    * update type information commands

ver 1.3



* improve parser functionality to overcome limitations
    might have to pass parser to exec to handle more complex operator usage cases

* implement ins{},del{} (special cases of existing functionality)

* add a do{n;f} operator to apply a function f for n times

* while{},until{} as loop operators

* have @ for rhs argument reference inside the operators

* inconsistencies with throwing exceptions or print error message and return in syscom.cpp
    should go through and convert all error printing returning code to actual exception throwing

* rewrite Makefile so less complex and ugly
* go through and remove unnecessary include statements, old inaccurate comments, other cruft...
* restructure the .cpp files so functions are defined in same order as declared in header files

* rename sequence to list and element to int for clarity (might)

* refactor code and update documentation

* UPDATE AND CHECK ALL USER PROGRAMS AFTER CHANGES SO THEY STILL WORK

* need better parser
    nested {} operators and composed expressions in operators
    probably need to embed/pass in the parser too

* might need to make some overloaded functions for the operators
    if, ccf, id, elm, seq, ...

----------------------------------------

etc... maybe???

* convert all to floating point
* consider merging the syscom commands into interpreter functions
* perhaps latex documentation

----------------------------------------

actual ideas

pointfree form references no arguments

pointful form uses the @ operator like the alpha and omega in APL

fill{@} operator, using the @ as the right hand argument reference

also allowing operators called in operators

def _abs = if{lt.fill{<@,0>};neg.fill{@};fill{@}}
def _abs2 = if{lt.fill{<@,0>};neg.id;id}
def _abs3 = if{lt.apr{0}.list;neg.id;id}
def _square = prod.fill{<@,@>}
def _square2 = red{*}.fill{<@,@>}
def _cube = prod.fill{<@,@,@>}
def _cube2 = red{*}.fill{<@,@,@>}
def _zero = if{eq.fill{<@,0>};~1;~0}
def _zero2 = if{eq.apr{0}.list;~1;~0}
def _even = if{zero.head.%.fill{<@,2>};~1;~0}
def _even2 = if{zero.head.%.apr{2}.list;~1;~0}
def _odd = if{not.zero.head.%.fill{<@,2>};~1;~0}
def _odd2 = if{not.zero.head.%.apr{2}.list;~1;~0}

potential ideas, (need better parser)

let l = <...>
let s1 = sum:l
let s2 = size:l
let l_avg0 = /:<s1,s2>
let l_avg1 = /:<sum:l,size:l>
let l_avg2 = /.apr{size:l}.list.sum:l

----------------------------------------



