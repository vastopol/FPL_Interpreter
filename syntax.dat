FP_REPL Interaction Guide
The "comprehensive" guide to FP_REPL syntax.

LANGUAGE SYNTAX
///*****************************************

~  = undefined

() = used for separation

application
    f:a
    where   function f applied to value a
    
composition  
    f.g
    where   (f.g):x = f:(g:x)
    
construction (ON THE FLY...)
    where   [1,2,3]  =  {1,2,3}
    
setting
    where  a = 4
        set element a to value 4
    where  c = [4,5,6]
        name and construct new sequence c
    where x = y
        set one unit to the other (if same type)
    
apply-to-all  @f       
    where   @f:{x1,...,xn}  =  {f:x1,...,f:xn}
    
    
condition 
    (h -> f,g)    
    where   (h -> f,g):x   
             =  f:x   if   h:x  =  T
             =  g:x   if   h:x  =  F
             =  ~    otherwise

///*****************************************


SYSTEM CALLS (for memory management)
///******************************************

* def == the definition function

syntax: def name = value

where element
   name = atom   
   x = 3
   
OR

where sequence
   name = {atom,...,atom}   
   s = {1,2,3}
   
   NO SPACES BETWEEN COMMAS
//----------------------------------------

* mac == macro creation function

syntax: mac name = value

on interpretation macros are substituted in

//----------------------------------------

* rm  == delete variable from memory

syntax: rm var

//----------------------------------------

* ls == prints contents of memory stored variables

syntax: ls

///*********************************************


EVALUATION
///*********************************************

Evaluation is invoked with the special symbol '#'
When the '#' is the first character in the input string,
evaluation is called on the sequence of characters immediately after.
eg.
>>> #F:x
evaluate("F:x").
evaluate(apply function f to variable x).
return result.

///*********************************************


STYLE GUIDELINES
///*******************************
- Functions are written in Uppercase 
- Macros are written in Uppercase

- Variable names should only contain Lowercase letters
- Each variable should be given a unique name
- Try to avoid having multiple variables defined as same value


because function definition is not implemented, use macros LIKE how composition works

ex.  
>>> mac G = ROTL.CAT
>>> def x = {1,2,3}
>>> def y = {5,6,7}

then use:
>>> #G:(x,y)

<<< {2,3,5,6,7,1}