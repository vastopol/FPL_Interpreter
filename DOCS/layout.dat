SYSCOM:
"syscom.h" is a set of functions which are responsible for the basic user interactions with the memory and system.
The simple routines are handled by the function "com" which, if a string does not match one of the arguments,
it passes control to another function, "exec" which handles memory management and input errors. "exec" handles adding to, removing from,
and printing the contents of the Memory object.

Syscom call:
def -> add variable (element/sequence)
mac -> add macro
rm -> remove
ls -> print

Memory operations used by syscoms:
add_element(x);
add_sequence(x);
add_macro(x);
remove_element(x);
remove_sequence(x);
remove_macro(x);
print_elements()
print_sequences()
print_macros();

//-----------------------------------------------------------------

CLASSES
- Pattern == compositional object / mediator
- Memory == data structure -> hold user defined variables/macros
- Node == data structure -> form of the syntax tree
- Interpreter == strategy pattern -> parsing
- Action == strategy pattern -> execution

On construction Pattern is initialized with an input string and a reference to the Memory object.
The Node pointer will initially be NULL. 

Pattern
{
    string input;   // user input
    Memory* mem;    // variable container
    Node* root;     // root of abstract syntax tree
    Interpreter* I; // for parsing
    Action* A;      // for executing
    
    // constructor, set, get, etc...
}

Memory
{
    map<string, int> elements;
    map<string, list<int> > sequences;
    map<string, string> macros;
    
    // constructor, set, get, print, etc...
}

Node
{
    std::string key;
    Node *parent, *left, *right;
    
    // constructor, set, get, etc...
}


Interpreter
{
    Node* parse(std::string);
    
    // helper functions
}


Action
{
    exec(Node*);

    // helper functions
}


-----------------------------------
object
{
    -sequence
    -connector 
        subclasses{ ':' | '.' }
    -function
        inheritance, strategy pattern?
}

nodes hold object pointer?